

%%  q=2, c=1. r=2. d=(c*r+1)/2. %%  > black lose!
%%  q=2, c=1. r=4. d=(c*r+1)/2. %%  > black lose!

%%  q=2, c=2. r=2. d=(c*r+1)/2. %%  > black win!
%%  q=2, c=3. r=2. d=(c*r+1)/2. %%  > black win!
%%  q=2, c=3. r=3. d=(c*r+1)/2. %%  > black win!

%%  q=3, c=3. r=3. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=4. r=3. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=4. r=4. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=5. r=5. d=(c*r+1)/2. %%  > black win!

%%  q=4, c=4. r=4. d=(c*r+1)/2. %%  > draw !
%%  q=4, c=6. r=4. d=(c*r+1)/2. %%  > white win!
%%  q=4, c=6. r=7. d=(c*r+1)/2. %%  > black win!
%%  q=4, c=7. r=6. d=(c*r+1)/2. %%  > original! black win!

%%%% easy
%%#const q=3.
%%#const c=3. 
%%#const r=3. 
%%#const d=(c*r+1)/2. 

%%  #const q=4.
%%  #const c=7. 
%%  #const r=6. 
%%  #const d=42. 

%#const d=c*r.
%#const d=2*((c*r+1)/2)-1. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% abd
#const q=4.
#const c=5. 
#const r=5. 

#const d=2. % 
#const maxColumn=8. % 

init[black,2,1].
init[white,2,2].
init[black,3,1].
init[white,3,2].
init[white,5,1].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

connect[0..q-1].

one[1]. 
zero[0].

% direction: used in the different winning configurations.
dir[0..1].

% domains for Row and Column . 
domR0[0..r].
domR[1..r].
topRow[r].
domC[1..c].

domC[C], domR[R]  ::  dom[C,R]. 

player[black]. 
player[white].

%% Time: 0 is the initial situation of the board before any moves are made
%% Time: 1 only black makes a move
%% Time: 2+ first white then black make moves

domT0[0..d].
domT[1..d].

domT[T], T>1 :: play[white,T].
domT[T],     :: play[black,T].

%% 1 estimate the number of bits needed for C columns
availableBit[0..10].
availableBit[I] :: exp[I,2**I,2**(I+1)]. %% assuming we have at least 2 columns
exp[E,A,B], A<c, B >= c :: maxBit[E].


maxBit[J] :: bit[0..J].
maxBit[J] :: allColumns[1..2**(J+1)].
bit[I], allColumns[C] :: choose[C,I,((C-1)/(2**I))#mod2]. 
maxBit[J] :: forbidden[c+1..2**J].

#exists[T], domT0[T], domT[T+1]                 :: won(T)? 
#forall[T], domT[T], T>1, bit[I]                :: moveU(I,T)? 
#exists[T], play[A,T], bit[I]                   :: move(A,I,T)? 
#exists[T], dom[C,R], domT0[T], player[A]       :: board(A,C,R,T)?
#exists[d], dom[C,R], C+(q-1)<=c, R<=r          :: winO(C,R,1)?
#exists[d], dom[C,R], C<=c , R+(q-1)<=r         :: winO(C,R,0)?
#exists[d], dom[C,R], dir[Z], C+q-1<=c,R+q-1<=r :: winD(C,R,Z)?

%~won(0). probably not needed .
~won(T) | won(T+1).

~board(black,C,R,T) | ~board(white,C,R,T).

~board(A,C,R,T) | board(A,C,R,T+1). 

~won(T) | board(A,C,R,T) | ~board(A,C,R,T+1).

~board(black,C,R+1,T+1) | board(black,C,R,T) | board(white,C,R,T+1).  %% gravity
~board(white,C,R+1,T+1) | board(black,C,R,T) | board(white,C,R,T).    %% gravity

init[A,C,R]                       ::  board(A,C,R,0).
dom[C,R], player[A], ~init[A,C,R] :: ~board(A,C,R,0).

%% FIX: white and black at least one!
%% FIX: At least one column has to be chosen 
%% FIX: dont choose columns that are full!
%% FIX: dont choose columns that are beyond!

%% if the column exists and the TopRow in that column is empty
%% then this is a legal move and it has to be done, 
%% otherwise this clause is satisfied. 
domC[C], choose[C,J,B], topRow[Top], domT[T], domT[T+1] ::  
    won(T) | 
    player[P] : board(P,C,Top,T) | 
    choose[C,I,0] :  moveU(I,T+1) | 
    choose[C,I,1] : ~moveU(I,T+1) | 
    one[B]  :  move(white,J,T+1) | 
    zero[B] : ~move(white,J,T+1).

%% Forces board(A,C,R,T+1) when it is correctly chosen  
domC[C], domR[R-1], domR[R], player[B], play[A,T], domT[T+1] ::  
    won(T) | 
    ~board(B,C,R-1,T) | 
    board(black,C,R,T) | 
    A == white : board(white,C,R,T) | 
    A == black : board(white,C,R,T+1) | 
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1) | 
    board(A,C,R,T+1).       

%% Excluding the moves for C > c.
forbidden[c+1..maxColumn].
domT[T], domT[T+1], player[A], forbidden[C] ::  
    won(T) |  %% is redundant, can be removed
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1).

%% if a board position [C,R] is chosen, 
%% then imply the corresponding bits for the move. 
dom[C,R], choose[C,I,B], play[A,T], domT[T+1] :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B]  :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).

dom[C,R], A == white, T==0 :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1).

dom[C,R], choose[C,I,B], A == black , T==0 :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B]  :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).

%% Winning Positions
% at least one winning position for black
dom[C+(q-1),R],   dom[C,R]         : winO(C,R,1) | 
dom[C,R+(q-1)],   dom[C,R]         : winO(C,R,0) | 
dom[C+q-1,R+q-1], dom[C,R], dir[Z] : winD(C,R,Z) .

% orthogonal: horizontal (Z==0) and vertical(Z==1) winning positions (winO)
dir[Z]              ::  connect[D] : ~board(white,C+Z*D,R+(1-Z)*D,d).
dir[Z], connect[D]  :: ~winO(C,R,Z) | board(black,C+Z*D,R+(1-Z)*D,d).

%%% diagonal rising (Z==0) and falling (Z==1) winning positions (winD)
dir[Z]             :: connect[D]   : ~board(white, C+D,R+Z*(q-1)+((-1)**Z)*D,d).
dir[Z], connect[D] :: ~winD(C,R,Z) |  board(black, C+D,R+Z*(q-1)+((-1)**Z)*D,d). 

