
#const q=3.
#const c=3. 
#const r=3. 
#const d=2. 

init[black,1,1].
init[white,3,1].

%%init[black,1,2].
%%init[white,1,3].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Basic Domains  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% columns      : c=1..
%% rows         : r=1..
topRow[r].
columns[c].
topRow[R] :: domR[1..R].
columns[C] :: domC[1..C].
domC[C], domR[R]  ::  dom[C,R]. 

one[1]. 
zero[0].
player[black]. 
player[white].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Time Management  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Time: 0 initial situation of the board before any moves
%% Time: 1 only black makes a move
%% Time: 2+ first white then black make moves

final[d].
final[F] :: domT0[0..F].
final[F] :: domT[1..F].

domT[T], T>1 :: play[white,T].
domT[T],     :: play[black,T].

% lastMove[Player,currentTimeStep,lastTimeBlackMove,lastTimeWhiteMove]
domT0[T], domT[T+1] :: lastMove[black,T+1,T,T+1].  %% FIXME isnt this domT
domT[T],  domT[T+1] :: lastMove[white,T+1,T,T  ]. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Winning configurations 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% connect      : q=0..
con[0..q-1].

%% Z==0: horizontal 
%%    1: vertical
%%    2: diagonal up 
%%    3: diagonal down
Z==0, dom[C,R], con[Q], dom[C    ,R+q-1] :: line[Z,C,R,C,  R+Q].
Z==1, dom[C,R], con[Q], dom[C+q-1,R    ] :: line[Z,C,R,C+Q,R  ].
Z==2, dom[C,R], con[Q], dom[C+q-1,R+q-1] :: line[Z,C,R,C+Q,R+Q].
Z==3, dom[C,R], con[Q], dom[C+q-1,R-q+1] :: line[Z,C,R,C+Q,R-Q].

line[Z,C,R,_,_] :: lineStart[Z,C,R].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%% Logarithmic Encoding   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% estimate the number of bits needed for C columns
availableBit[0..10]. %% assuming we have less than 2^10 columns :)
availableBit[I] :: exp[I,2**I,2**(I+1)]. 
columns[C], exp[E,A,B], A<C, B >= C :: maxBit[E].

maxBit[J] :: bit[0..J].

%% Excluding the moves for C > c.
maxBit[J] :: allColumns[1..2**(J+1)].
maxBit[J] :: forbidden[c+1..2**(J+1)].

bit[I], allColumns[C] :: choose[C,I,((C-1)/(2**I))#mod2]. 

#exists[T], domT0[T], domT[T+1]             :: won(T)? 
#forall[T], domT[T], T>1, bit[I]            :: moveU(I,T)? 
%#exists[T], domT[T], T>1, bit[I]            :: moveU(I,T)? for debugging
#exists[T], play[A,T], bit[I]               :: move(A,I,T)? 
#exists[T], dom[C,R], domT0[T], player[A]   :: board(A,C,R,T)?
#exists[F], final[F], lineStart[Z,C,R]      :: winL(Z,C,R)?

%~won(0). probably not needed .
~won(T) | won(T+1).

player[A] : ~board(A,C,R,T).

~board(A,C,R,T) | board(A,C,R,T+1). 

~won(T) | board(A,C,R,T) | ~board(A,C,R,T+1).

%% Gravity  
%%%%%  board(black,C,R+1,T+1) => board(black,C,R,T) | board(white,C,R,T+1)
lastMove[A,T,BlackPrevious,WhitePrevious] :: 
    ~board(A,C,R+1,T) | 
     board(black,C,R,BlackPrevious) | 
     board(white,C,R,WhitePrevious). 

init[A,C,R]                       ::  board(A,C,R,0).
dom[C,R], player[A], ~init[A,C,R] :: ~board(A,C,R,0).

%% constraints:
%% At least one column has to be chosen
%% This column is not full and not beyond (>c).
%% Full: at previous (diff for black and white) move 
%% the top Row in that column is empty.

%% if the column exists and the TopRow in that column is empty
%% then this is a legal move and it has to be done, 
%% otherwise this clause is satisfied and moveU 
%% does not force anything on move: 
domC[C], choose[C,J,B], topRow[Top], domT[T], domT[T+1] ::  
    won(T) | 
    player[P] : board(P,C,Top,T) | 
    choose[C,I,0] :  moveU(I,T+1) | 
    choose[C,I,1] : ~moveU(I,T+1) | 
    one[B]  :  move(white,J,T+1) | 
    zero[B] : ~move(white,J,T+1).

%% Forces board(A,C,R,T+1) when it is correctly chosen  

%% (
%%     Bits tell us the column, 
%%     choose[C,I,0] : ~move(A,I,T+1), choose[C,I,1] :  move(A,I,T+1) 
%%     Previous row is occupied
%%     board(B,C,R-1,T) 
%%     Its currently unoccupied
%%     ~board(black,C,R,T), 
%%     A == white: ~board(white,C,R,T) % for white
%%     A == black: ~board(white,C,R,T+1) % for blacks move
%% )=> board(A,C,R,T+1).       

domC[C], domR[R-1], player[B], domR[R], play[A,T+1] ::  
    won(T) | 
    ~board(B,C,R-1,T) |  %% why this here ? 
    board(black,C,R,T) | 
    A == white : board(white,C,R,T) | 
    A == black : board(white,C,R,T+1) | 
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1) | 
    board(A,C,R,T+1).       

%    (~won(T), board(B,C,R,T) ) => 
%    choose[C,I,0] :  move(A,I,T+1) | 
%    choose[C,I,1] : ~move(A,I,T+1).
%%% Dont choose a column that is already full 
domC[C], player[B], topRow[R], play[A,T+1] ::  
    won(T) | %% might be redundant  
    ~board(B,C,R,T) |  
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1).

%    (~won(T), board(white,C,R,T+1) ) => 
%    choose[C,I,0] :  move(black,I,T+1) | 
%    choose[C,I,1] : ~move(black,I,T+1).
domC[C], topRow[Top], play[black,T] ::  
    won(T) |  %% might be redundant 
    ~board(white,C,Top,T) |  
    choose[C,I,0] :  move(black,I,T) |
    choose[C,I,1] : ~move(black,I,T).

%% if not yet one, then exclude moves outside 
%% ~won(T) => 
%% choose[C,I,0] :  move(A,I,T+1) | 
%% choose[C,I,1] : ~move(A,I,T+1).
play[A,T+1], forbidden[C] ::  
    won(T) |  %% is redundant, can be removed
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1).

%% if a board position [C,R] is chosen, 
%% then imply the corresponding bits for the move. 
%% (~board(A,C,R,T),board(A,C,R,T+1)) => set corresponding bits
dom[C,R], choose[C,I,B], play[A,T+1] :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B]  :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).

dom[C,R], A == white, T==0 :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1).

dom[C,R], choose[C,I,B], A == black , T==0 :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B]  :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).

%%%%% Winning Positions
% at least one winning position for black
lineStart[Z,C,R] : winL(Z,C,R).
final[F], line[Z,C,R,C2,R2] :: ~winL(Z,C,R) | board(black,C2,R2,F).
% avoid reaching a winning position of white.
final[F], lineStart[Z,C,R]  :: line[Z,C,R,C2,R2] : ~board(white,C2,R2,F).


