%#const q=3.
%#const c=4.
%#const r=4.
%#const d=13.

%init[black,2,1].
%init[white,2,2].

%init[black,1,2].
%init[white,1,3].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Basic Domains
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% columns      : c=1..
%% rows         : r=1..
topRow[r].
columns[c].
columns[C], topRow[R] :: dom[1..C,1..R].

one[1]. zero[0].
oneOrZero[0]. oneOrZero[1].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Time Management
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Time: 0 initial black situation of the board before any moves
%% Time: 1 initial white situation
%% Time: 2 first black move
%% Time: 3 first white move ...

final[d]. %%% d odd means first player wins. d even means second player wins.
final[F] :: domT[-1..F].
setup[-1]. setup[0].

domT[T], final[F], (F-T) #mod2 == 0 :: parity[winner,T].
domT[T], final[F], (F-T) #mod2 == 1 :: parity[loser,T].
domT[T-2], domT[T] :: playTurn[T].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Winning configurations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% connect      : q=0..
con[0..q-1].

%% Z==0: horizontal %% 1: vertical %% 2: diagonal up %% 3: diagonal down
Z==0, dom[C,R], con[Q], dom[C    ,R+q-1] :: line[Z,C,R,C,  R+Q].
Z==1, dom[C,R], con[Q], dom[C+q-1,R    ] :: line[Z,C,R,C+Q,R  ].
Z==2, dom[C,R], con[Q], dom[C+q-1,R+q-1] :: line[Z,C,R,C+Q,R+Q].
Z==3, dom[C,R], con[Q], dom[C+q-1,R-q+1] :: line[Z,C,R,C+Q,R-Q].

line[Z,C,R,_,_] :: lineStart[Z,C,R].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Logarithmic Encoding
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% estimate the number of bits needed for C columns
availableBit[0..10]. %% assuming we have less than 2^10 columns :)
availableBit[I] :: exp[I,2**I,2**(I+1)].
columns[C], exp[E,A,B], A<C, B >= C :: maxBit[E].

maxBit[J] :: bit[0..J].

%% Excluding the moves for C > c.
maxBit[J]             :: allColumns[1..2**(J+1)].
maxBit[J], columns[C] :: forbidden[C+1..2**(J+1)].

bit[I], allColumns[C] :: choose[C,I,((C-1)/(2**I))#mod2].

#exists[T], domT[T], ~final[T]          :: won(T)?
#forall[T], playTurn[T], parity[loser,T], bit[I] :: moveU(I,T)?
%#exists[T], playTurn[T], parity[loser,T], bit[I] :: moveU(I,T)? % for debugging
#exists[T], playTurn[T], bit[I]         :: move(I,T)?
#exists[T], domT[T], dom[C,R]           :: board(C,R,T)?
#exists[F], final[F], lineStart[Z,C,R]  :: winL(Z,C,R)?

playTurn[T+1] :: ~won(T) | won(T+1).

playTurn[T+2], dom[C,R] ::             ~board(C,R,T) |  board(C,R,T+2).
playTurn[T+2], dom[C,R] :: ~won(T+1) |  board(C,R,T) | ~board(C,R,T+2).

%%%% Gravity
playTurn[T+2] ::
    ~board(C,R+1,T+2) |
     board(C,R,T) |
     board(C,R,T+1).

setup[T], parity[A,T],            init[A,C,R] ::  board(C,R,T).
setup[T], parity[A,T], dom[C,R], ~init[A,C,R] :: ~board(C,R,T).

%% constraints:
%% At least one column has to be chosen
%% This column is not full and not beyond (>c).
%% Full: at previous (diff for black and white) move
%% the top Row in that column is empty.

%% if the column exists and the TopRow in that column is empty
%% then this is a legal move and it has to be done,
%% otherwise this clause is satisfied and moveU
%% does not force anything on move:
dom[C,R], choose[C,J,B], topRow[R], playTurn[T+2], parity[loser,T] ::
    won(T+1) |
    board(C,R,T) |
    board(C,R,T+1) |
    choose[C,I,0] :  moveU(I,T+2) |
    choose[C,I,1] : ~moveU(I,T+2) |
    zero[B] : ~move(J,T+2) | one[B] : move(J,T+2).

%%%%%%%%% When a non-empty column is chosen, make sure the next row is updated.
dom[C,R], dom[C,R-1], playTurn[T+2], oneOrZero[Z] ::
    won(T+1) |
    zero[Z] : ~board(C,R-1,T) | one[Z] : ~board(C,R-1,T+1) |
    board(C,R,T) |
    board(C,R,T+1) |
    choose[C,I,0] :  move(I,T+2) |
    choose[C,I,1] : ~move(I,T+2) |
    board(C,R,T+2).% | debug.

%%%%%%%%% When an empty column is chosen, make sure the next row is updated.
dom[C,R], R==1, playTurn[T+2] ::
    won(T+1) |
    board(C,R,T) |
    board(C,R,T+1) |
    choose[C,I,0] : move(I,T+2) |
    choose[C,I,1] : ~move(I,T+2) |
    board(C,R,T+2).

%%%% if we reached the top row in a column C, we can't play in C anymore
dom[C,R], topRow[R], playTurn[T+2], oneOrZero[Z] ::
    zero[Z] : ~board(C,R,T) | one[Z] : ~board(C,R,T+1) |
    choose[C,I,0] : move(I,T+2) |
    choose[C,I,1] : ~move(I,T+2).
%%%%% A == loser : won(T+1) | A == winner : won(T) |  %% REDUNDANT!

%% if not yet one, then exclude moves outside the board (too large column)
playTurn[T+2], forbidden[C] ::
    choose[C,I,0] : move(I,T+2) |
    choose[C,I,1] : ~move(I,T+2).
%%%%% A == loser : won(T+1) | A == winner : won(T) |  %% REDUNDANT!

%% if a board position [C,R] is chosen,
%% then imply the corresponding bits for the move.
dom[C,R], choose[C,I,B], playTurn[T+2] ::
    board(C,R,T) |
   ~board(C,R,T+2) |
    one[B] : move(I,T+2) | zero[B] : ~move(I,T+2).

%%%% cannot have two players on the same location.
dom[C,R], domT[T] ::
  ~board(C,R,T) | ~board(C,R,T+1).

%%%%%%% Winning Positions
%%% at least one winning position for the existential player
lineStart[Z,C,R] : winL(Z,C,R).
final[F], line[Z,C,R,C2,R2] :: ~winL(Z,C,R) | board(C2,R2,F).
%%% avoid reaching a winning position of the opponent.
final[F], lineStart[Z,C,R]  :: line[Z,C,R,C2,R2] : ~board(C2,R2,F-1).
