%%  q=2, c=1. r=2. d=(c*r+1)/2. %%  > black lose!
%%  q=2, c=1. r=4. d=(c*r+1)/2. %%  > black lose!

%%  q=2, c=2. r=2. d=(c*r+1)/2. %%  > black win!
%%  q=2, c=3. r=2. d=(c*r+1)/2. %%  > black win!
%%  q=2, c=3. r=3. d=(c*r+1)/2. %%  > black win!

%%  q=3, c=3. r=3. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=4. r=3. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=4. r=4. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=5. r=5. d=(c*r+1)/2. %%  > black win!

%%  q=4, c=4. r=4. d=(c*r+1)/2. %%  > draw !
%%  q=4, c=6. r=4. d=(c*r+1)/2. %%  > white win!
%%  q=4, c=6. r=7. d=(c*r+1)/2. %%  > black win!
%%  q=4, c=7. r=6. d=(c*r+1)/2. %%  > original! black win!

%% easy
#const q=3.
#const c=3. 
#const r=3. 
#const d=(c*r+1)/2. 

%%  #const q=4.
%%  #const c=7. 
%%  #const r=6. 
%%  #const d=42. 

%#const d=c*r.
%#const d=2*((c*r+1)/2)-1. 

connect[0..q-1].

one[1]. 
zero[0].

% direction: used in the different winning configurations.
dir[0..1].

% domains for Row and Column . 
domR0[0..r].
domR[1..r].
domC[1..c].

domC[C], domR[R]  ::  dom[C,R]. 
player[black]. player[white].

%% Time: 0 is intial position before moves are made
%% Time: 1 only black moves 
%% Time: 2+ first white then black 

domT0[0..d].
domT[1..d].

maxBit[0..10].
domC[C], maxBit[I], 2**I <= c :: choose[C,I,(C/(2**I))#mod2]. 
choose[_,I,_] :: bit[I]. 

#exists[T], domT[T], domT[T+1]                  :: won(T)? 
#exists[T], domT[T], bit[I]                     :: move(black,I,T)? 
#forall[T], domT[T], T>1, bit[I]                :: moveL(white,I,T)? 
#exists[T], domT[T], T>1, bit[I]                :: move(white,I,T)? 
#exists[T], dom[C,R], domT0[T], player[A]       :: board(A,C,R,T)?
#exists[d], dom[C,R], C+(q-1)<=c, R<=r          :: winO(C,R,1)?
#exists[d], dom[C,R], C<=c , R+(q-1)<=r         :: winO(C,R,0)?
#exists[d], dom[C,R], dir[Z], C+q-1<=c,R+q-1<=r :: winD(C,R,Z)?

~won(T) | won(T+1).

~board(black,C,R,T) | ~board(white,C,R,T).

~board(A,C,R,T) | board(A,C,R,T+1). 

~won(T) | board(A,C,R,T) | ~board(A,C,R,T+1).

~board(black,C,R+1,T+1) | board(black,C,R,T) | board(white,C,R,T+1).  %% gravity
~board(white,C,R+1,T+1) | board(black,C,R,T) | board(white,C,R,T).    %% gravity

init[A,C,R]                       ::  board(A,C,R,0).
dom[C,R], player[A], ~init[A,C,R] :: ~board(A,C,R,0).

%% FIX: white and black at least one!
%% FIX: dont choose columns that do not exist!

domC[C], domT[T], domT[T+1], player[P], player[A] ::  
    won(T) | 
   ~board(P,C,R-1,T) | 
    board(black,C,R,T) | 
    board(white,C,R,T) | 
    choose[C,I,0] :  moveL(A,I,T+1) | 
    choose[C,I,1] : ~moveL(A,I,T+1) | 
    board(A,C,R,T+1).       

%% if a board position [C,R] is chosen, 
%% then imply the corresponding bits for the move. 
dom[C,R], choose[C,I,B], player[A] :: 
    % board(white,C,R,T) | board(black,C,R,T) |
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B]  :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).
 

%% Winning Positions
% at least one winning position for black
dom[C+(q-1),R],   dom[C,R]         : winO(C,R,1) | 
dom[C,R+(q-1)],   dom[C,R]         : winO(C,R,0) | 
dom[C+q-1,R+q-1], dom[C,R], dir[Z] : winD(C,R,Z) .

% orthogonal: horizontal (Z==0) and vertical(Z==1) winning positions (winO)
dir[Z]              ::  connect[D] : ~board(white,C+Z*D,R+(1-Z)*D,d).
dir[Z], connect[D]  :: ~winO(C,R,Z) | board(black,C+Z*D,R+(1-Z)*D,d).

%%% diagonal rising (Z==0) and falling (Z==1) winning positions (winD)
dir[Z]             :: connect[D]   : ~board(white, C+D,R+Z*(q-1)+((-1)**Z)*D,d).
dir[Z], connect[D] :: ~winD(C,R,Z) |  board(black, C+D,R+Z*(q-1)+((-1)**Z)*D,d). 

