
%%  q=2, c=1. r=2. d=(c*r+1)/2. %%  > black lose!
%%  q=2, c=1. r=4. d=(c*r+1)/2. %%  > black lose!

%%  q=2, c=2. r=2. d=(c*r+1)/2. %%  > black win!
%%  q=2, c=3. r=2. d=(c*r+1)/2. %%  > black win!
%%  q=2, c=3. r=3. d=(c*r+1)/2. %%  > black win!

%%  q=3, c=3. r=3. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=4. r=3. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=4. r=4. d=(c*r+1)/2. %%  > black win!
%%  q=3, c=5. r=5. d=(c*r+1)/2. %%  > black win!

%%  q=4, c=4. r=4. d=(c*r+1)/2. %%  > draw !
%%  q=4, c=6. r=4. d=(c*r+1)/2. %%  > white win!
%%  q=4, c=6. r=7. d=(c*r+1)/2. %%  > black win!
%%  q=4, c=7. r=6. d=(c*r+1)/2. %%  > original! black win!

#const q=3.
#const c=3. 
#const r=3. 
#const d=2. 

init[black,1,1].
init[white,3,1].

%%init[black,1,2].
%%init[white,1,3].


%%%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%  %% abd
%%%  %% BUGGY Example> Black should not be able to win
%%%  #const q=4.
%%%  #const c=5. 
%%%  #const r=5. 
%%%  
%%%  #const d=2. % 
%%%  
%%%  init[black,2,1].
%%%  init[white,2,2].
%%%  init[black,3,1].
%%%  init[white,3,2].
%%%  
%%%  init[white,1,1].
%%%  init[white,4,1].
%%%  init[black,5,1].
%%%  
%%%  %5       
%%%  %4      
%%%  %3      
%%%  %2 WW   
%%%  %1WBBWB
%%%  % 12345
%%%  %%%%%%%%%%%%%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%  Should be SAT but is UNSAT
%% #const q=3.
%% #const c=4. 
%% #const r=1. 
%% 
%% #const d=2. % 
%% 
%% init[black,2,1].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% abd
%%#const q=3.
%%#const c=3. 
%%#const r=3. 
%%
%%#const d=2. % 
%% 
%% init[black,2,1].
%% init[black,4,1].


%init[white,1,1].
%init[black,3,1].

%% init[white,1,2].
%% init[black,2,2].
%% init[black,3,2].
%% init[white,4,2].
%% init[white,5,2].
%% 
%% init[black,1,3].
%% init[white,2,3].
%% init[white,3,3].
%% init[black,4,3].
%% init[black,5,3].
%% 
%% init[white,1,4].
%% init[black,2,4].
%% init[black,3,4].
%% init[white,4,4].
%% init[white,5,4].
%% 
%% init[black,3,5].
%% init[black,2,5].
%% init[white,5,5].


%5 BB W
%4WBBWW       
%3BWWBB      
%2WBBWW       
%1BWWBB      
% 12345
%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

connect[0..q-1].

one[1]. 
zero[0].

final[d].

% domains for Row and Column . 
domR0[0..r].
domR[1..r].
topRow[r].
domC[1..c].

domC[C], domR[R]  ::  dom[C,R]. 

% direction: used in the different winning configurations.
dir[0..3].

%% Z==0: horisontal 
dom[C,R], connect[Q], dom[C,R+q-1] :: line[0,C,R,C,R+Q].
%% Z==1: vertical
dom[C,R], connect[Q], dom[C+q-1,R] :: line[1,C,R,C+Q,R].
%% Z==2: diagonal up 
dom[C,R], connect[Q], dom[C+q-1,R+q-1] :: line[2,C,R,C+Q,R+Q].
%% Z==3: diagonal down
dom[C,R], connect[Q], dom[C+q-1,R-q+1] :: line[3,C,R,C+Q,R-Q].

line[Z,C,R,_,_] :: lineStart[Z,C,R].


player[black]. 
player[white].

%% Time: 0 is the initial situation of the board before any moves are made
%% Time: 1 only black makes a move
%% Time: 2+ first white then black make moves

final[F] :: domT0[0..F].
final[F] :: domT[1..F].

domT[T], T>1 :: play[white,T].
domT[T],     :: play[black,T].

%%%%%%%%%%%%%%% 
%%% FIXME: merge clauses using this new fact:  
%%%%%%%%%%%%%%% 
% lastMove[Player,currentTimeStep,lastBlackMove,lastWhiteMove]
domT0[T],domT[T+1] :: lastMove[black,T+1,T,T+1]. 
domT[T], domT[T+1] :: lastMove[white,T+1,T,T]. 

%% estimate the number of bits needed for C columns
availableBit[0..10].
availableBit[I] :: exp[I,2**I,2**(I+1)]. %% assuming we have at least 2 columns
exp[E,A,B], A<c, B >= c :: maxBit[E].


%% Excluding the moves for C > c.
maxBit[J] :: forbidden[c+1..2**(J+1)].

maxBit[J] :: bit[0..J].
maxBit[J] :: allColumns[1..2**(J+1)].
bit[I], allColumns[C] :: choose[C,I,((C-1)/(2**I))#mod2]. 

#exists[T], domT0[T], domT[T+1]             :: won(T)? 
#forall[T], domT[T], T>1, bit[I]            :: moveU(I,T)? 
%#exists[T], domT[T], T>1, bit[I]            :: moveU(I,T)? 
#exists[T], play[A,T], bit[I]               :: move(A,I,T)? 
#exists[T], dom[C,R], domT0[T], player[A]   :: board(A,C,R,T)?
#exists[F], final[F], lineStart[Z,C,R]      :: winL(Z,C,R)?

%~won(0). probably not needed .
~won(T) | won(T+1).

~board(black,C,R,T) | ~board(white,C,R,T).

~board(A,C,R,T) | board(A,C,R,T+1). 

~won(T) | board(A,C,R,T) | ~board(A,C,R,T+1).

%%%%%  board(black,C,R+1,T+1) => board(black,C,R,T) | board(white,C,R,T+1)
lastMove[A,T,BlackPrevious,WhitePrevious] :: 
    ~board(A,C,R+1,T) | 
     board(black,C,R,BlackPrevious) | 
     board(white,C,R,WhitePrevious). %% gravity

init[A,C,R]                       ::  board(A,C,R,0).
dom[C,R], player[A], ~init[A,C,R] :: ~board(A,C,R,0).

%% constraints:
%% white and black at least one!
%% At least one column has to be chosen 
%% dont choose columns that are full!
%% dont choose columns that are beyond!

%% if the column exists and the TopRow in that column is empty
%% then this is a legal move and it has to be done, 
%% otherwise this clause is satisfied. 
domC[C], choose[C,J,B], topRow[Top], domT[T], domT[T+1] ::  
    won(T) | 
    player[P] : board(P,C,Top,T) | 
    choose[C,I,0] :  moveU(I,T+1) | 
    choose[C,I,1] : ~moveU(I,T+1) | 
    one[B]  :  move(white,J,T+1) | 
    zero[B] : ~move(white,J,T+1).

%% Forces board(A,C,R,T+1) when it is correctly chosen  

%% (
%%     Bits tell us the column, 
%%     choose[C,I,0] : ~move(A,I,T+1), choose[C,I,1] :  move(A,I,T+1) 
%%     Previous row is occupied
%%     board(B,C,R-1,T) 
%%     Its currently unoccupied
%%     ~board(black,C,R,T), 
%%     A == white: ~board(white,C,R,T) % for white
%%     A == black: ~board(white,C,R,T+1) % for blacks move
%% )=> board(A,C,R,T+1).       

domC[C], domR[R-1], player[B], domR[R], play[A,T+1] ::  
    won(T) | 
    ~board(B,C,R-1,T) |  %% why this here ? 
    board(black,C,R,T) | 
    A == white : board(white,C,R,T) | 
    A == black : board(white,C,R,T+1) | 
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1) | 
    board(A,C,R,T+1).       

%    (~won(T), board(B,C,R,T) ) => 
%    choose[C,I,0] :  move(A,I,T+1) | 
%    choose[C,I,1] : ~move(A,I,T+1).
%%% Dont choose a column that is already full 
domC[C], player[B], topRow[R], play[A,T+1] ::  
    won(T) | %% might be redundant  
    ~board(B,C,R,T) |  
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1).

%    (~won(T), board(white,C,R,T+1) ) => 
%    choose[C,I,0] :  move(black,I,T+1) | 
%    choose[C,I,1] : ~move(black,I,T+1).
domC[C], topRow[Top], play[black,T] ::  
    won(T) |  %% might be redundant 
    ~board(white,C,Top,T) |  
    choose[C,I,0] :  move(black,I,T) |
    choose[C,I,1] : ~move(black,I,T).

%% if not yet one, then exclude moves outside 
%% ~won(T) => 
%% choose[C,I,0] :  move(A,I,T+1) | 
%% choose[C,I,1] : ~move(A,I,T+1).
play[A,T+1], forbidden[C] ::  
    won(T) |  %% is redundant, can be removed
    choose[C,I,0] :  move(A,I,T+1) | 
    choose[C,I,1] : ~move(A,I,T+1).


%% if a board position [C,R] is chosen, 
%% then imply the corresponding bits for the move. 
%% (~board(A,C,R,T),board(A,C,R,T+1)) => set corresponding bits
dom[C,R], choose[C,I,B], play[A,T], domT[T+1] :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B] :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).

dom[C,R], A == white, T==0 :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1).

dom[C,R], choose[C,I,B], A == black , T==0 :: 
    board(A,C,R,T) |
   ~board(A,C,R,T+1) | 
    one[B]  :  move(A,I,T+1) | 
    zero[B] : ~move(A,I,T+1).

%%%%% Winning Positions
% at least one winning position for black
lineStart[Z,C,R] : winL(Z,C,R).
final[F], line[Z,C,R,C2,R2] :: ~winL(Z,C,R) | board(black,C2,R2,F).
% avoid reaching a winning position of white.
final[F], lineStart[Z,C,R]  :: line[Z,C,R,C2,R2] : ~board(white,C2,R2,F).
