
%%  q=2, c=1. r=2. d=c*r. %%  > black lose!
%%  q=2, c=1. r=4. d=c*r. %%  > black lose!

%%  q=2, c=2. r=2. d=c*r. %%  > black win!
%%  q=2, c=3. r=2. d=c*r. %%  > black win!
%%  q=2, c=3. r=3. d=c*r. %%  > black win!


%%  q=3, c=3. r=3. d=c*r. %%  > draw !
%%  q=3, c=4. r=3. d=c*r. %%  > black win!
%%  q=3, c=4. r=4. d=c*r. %%  > black win!
%%  q=3, c=5. r=5. d=c*r. %%  > black win!

%%  q=4, c=4. r=4. d=c*r. %%  > draw !
%%  q=4, c=6. r=4. d=c*r. %%  > white win!
%%  q=4, c=6. r=7. d=c*r. %%  > black win!
%%  q=4, c=7. r=6. d=c*r. %%  > original! black win!

%% %% %% easy
%% #const q=3. 
%% #const c=3. 
%% #const r=3. 
%% #const d=3. 

%% %% easy
#const q=2. 
#const c=2. 
#const r=2. 
#const d=c*r. 

connect[0..q-1].

black[1].
white[0].
player[0..1].
direction[0..1].

domC[1..c].
domR[1..r].
domR0[0..r].
domC[C], domR[R] => dom[C,R]. 

domT[1..d].
domT0[0..d].
domT[T] => turn[T,T#mod2]. 

domC[C], domC[I], 2**I <= c => chooseC[C,I,(C/(2**I))#mod2]. 
chooseC[_,I,_] => bitC[I]. 

domT[T]                            => #exist(T) , time(T).
bitC[I], domT[T]                   => #forall(T), moveL(I,T). 
turn[T,A], domC[C]                 => #exist(T) , move(A,C,T).    
domC[C], domR0[R], domT0[T], R>=T  => #exist(T) , occupied(C,R,T). 
dom[C,R]                           => #exist(d) , board(C,R).
dom[C,R], direction[Z]             => #exist(d) , winO(C,R,Z).  
dom[C,R], direction[Z]             => #exist(d) , winD(C,R,Z).  

~time(T+1), time(T).

~move(_,_,T), time(T). 
~move(_,C,T), ~occupied(C,r,T-1). 

black[A], chooseC[C,I,0] => ~move(A,C,T), ~moveL(I,T).
black[A], chooseC[C,I,1] => ~move(A,C,T), moveL(I,T).

white[A] => ~time(T), occupied(C,r,T), 
     moveL(I,T) : chooseC[C,I,0], 
    ~moveL(I,T) : chooseC[C,I,1], 
    move(A,C,T).

 occupied(_C,0,0).
~occupied(_C,1,0).
~occupied(C,R,T), occupied(C,R-1,T).  %% gravity!!
~occupied(C,R,T), occupied(C,R,T+1). 
black[A] => ~occupied(C,R-1,T), occupied(C,R,T-1), ~move(A,C,T),  board(C,R). 
white[A] => ~occupied(C,R-1,T), occupied(C,R,T-1), ~move(A,C,T), ~board(C,R). 
~occupied(C,R-1,T-1), occupied(C,R,T-1), ~move(_A,C,T), occupied(C,R,T). 

turn[T,A] => move(A,C,T):domC[C]. 

%% Winning Positions

% at least one winning position for black
%time(d),  %% Add this if BlackNoLose
    winO(C,R,1):C+(q-1)<=c:R<=r:dom[C,R], 
    winO(C,R,0):C<=c:R+(q-1)<=r:dom[C,R], 
    winD(C,R,Z):C+q-1<=c:R+q-1<=r:dom[C,R]:direction[Z].

% orthogonal: horizontal (Z==0) and vertical(Z==1) winning positions (winO)
direction[Z]   => board(_C+Z*D,_R+(1-Z)*D) : connect[D].
direction[Z], connect[D] => board(C+Z*D,R+(1-Z)*D),    ~winO(C,R,Z).
direction[Z], connect[D] => occupied(C+Z*D,R+(1-Z)*D,d), ~winO(C,R,Z).
%%
%%% diagonal rising (Z==0) and falling (Z==1) winning positions (winD)
direction[Z]   => board(_C+D,_R+Z*(q-1)+((-1)**Z)*D) : connect[D].
direction[Z], connect[D] => board(C+D,R+Z*(q-1)+((-1)**Z)*D),    ~winD(C,R,Z). 
direction[Z], connect[D] => occupied(C+D,R+Z*(q-1)+((-1)**Z)*D,d), ~winD(C,R,Z). 
