
%%  q=2, c=1. r=2. d=c*r. %%  > black lose!
%%  q=2, c=1. r=4. d=c*r. %%  > black lose!

%%  q=2, c=2. r=2. d=c*r. %%  > black win!
%%  q=2, c=3. r=2. d=c*r. %%  > black win!
%%  q=2, c=3. r=3. d=c*r. %%  > black win!

%%  q=3, c=3. r=3. d=c*r. %%  > draw !
%%  q=3, c=4. r=3. d=c*r. %%  > black win!
%%  q=3, c=4. r=4. d=c*r. %%  > black win!
%%  q=3, c=5. r=5. d=c*r. %%  > black win!

%%  q=4, c=4. r=4. d=c*r. %%  > draw !
%%  q=4, c=6. r=4. d=c*r. %%  > white win!
%%  q=4, c=6. r=7. d=c*r. %%  > black win!
%%  q=4, c=7. r=6. d=c*r. %%  > original! black win!

%% %% easy
#const q=2. 
#const c=2. 
#const r=2. 
%#const d=3. 
#const d=2*((c*r)/2)-1. 

connect[0..q-1].

black[1].
white[0].
player[0..1].
dir[0..1].

domR0[0..r].
domR[1..r].
domC[1..c].

domC[C], domR[R] => dom[C,R]. 

domT0[0..d].
domT[1..d].
domT[T] => turn[T,T#mod2]. 

domC[C], domC[I], 2**(I-1) <= c => chooseC[C,I-1,(C/(2**(I-1)))#mod2]. 
chooseC[_,I,_] => bitC[I]. 

domT[T]                              => #exist(T-1) , time(T).
white[A], bitC[I], turn[T,A]         => #forall(T), moveL(I,T). 
black[A], bitC[I], turn[T,A]         => #exist(T), moveL(I,T). 
turn[T,A], domC[C]                   => #exist(T) , move(A,C,T).    
%domC[C], domR0[R], domT0[T], R <= T  => #exist(T) , occupied(C,R,T). 
domC[C], domR0[R], domT0[T]          => #exist(T) , occupied(C,R,T). 
dom[C,R]                             => #exist(d) , board(C,R).
dom[C,R], C+(q-1)<=c, R<=r           => #exist(d) , winO(C,R,1).  
dom[C,R], C<=c , R+(q-1)<=r          => #exist(d) , winO(C,R,0).  
dom[C,R], dir[Z], C+q-1<=c,R+q-1<=r  => #exist(d) , winD(C,R,Z).  

~time(T+1), time(T).
white[A], turn[T,A] => ~time(T), time(T+1).

~move(_,_,T), time(T). 
~move(_,C,T), ~occupied(C,r,T-1). 

black[A], chooseC[C,I,0] => ~move(A,C,T), ~moveL(I,T).
black[A], chooseC[C,I,1] => ~move(A,C,T), moveL(I,T).

white[A], domC[C] => ~time(T), occupied(C,r,T), 
     moveL(I,T) : chooseC[C,I,0], 
    ~moveL(I,T) : chooseC[C,I,1], 
    move(A,C,T).

 occupied(_C,0,0).
~occupied(_C,1,0).
~occupied(C,R,T),    occupied(C,R-1,T).  %% gravity!!
~occupied(C,R,T-1),  occupied(C,R,T). 
 occupied(C,R,T-1), ~occupied(C,R,T), move(_,C,T).

black[A]            =>  move(A,C,T) : turn[T,A], ~occupied(C,R,d), ~board(C,R). 
black[A], turn[T,A] => occupied(C,R-1,T-1), ~move(A,C,T), ~board(C,R). 
black[A], turn[T,A] => ~occupied(C,R,T-1),  ~move(A,C,T), ~board(C,R). 
white[A], turn[T,A] => ~occupied(C,R-1,T-1), occupied(C,R,T-1), ~move(A,C,T), ~board(C,R). 

~occupied(C,R-1,T-1), occupied(C,R,T-1), ~move(_A,C,T), occupied(C,R,T). 

turn[T,A] => ~time(T), move(A,C,T):domC[C]. 
              time(T), occupied(C,R,T-1), ~occupied(C,R,T). 

%% Winning Positions

% at least one winning position for black
%time(d),  %% Add this if BlackNoLose
    winO(C,R,1) : C+(q-1)<=c : R<=r       : dom[C,R], 
    winO(C,R,0) : C<=c       : R+(q-1)<=r : dom[C,R], 
    winD(C,R,Z) : C+q-1<=c   : R+q-1<=r   : dom[C,R] : dir[Z].

% orthogonal: horizontal (Z==0) and vertical(Z==1) winning positions (winO)
dir[Z]             =>    board(C+Z*D,R+(1-Z)*D)  : connect[D].
dir[Z], connect[D] =>    board(C+Z*D,R+(1-Z)*D)  , ~winO(C,R,Z).
dir[Z], connect[D] => occupied(C+Z*D,R+(1-Z)*D,d), ~winO(C,R,Z).
%%
%%% diagonal rising (Z==0) and falling (Z==1) winning positions (winD)
dir[Z]             =>    board(C+D,R+Z*(q-1)+((-1)**Z)*D)  : connect[D].
dir[Z], connect[D] =>    board(C+D,R+Z*(q-1)+((-1)**Z)*D)  , ~winD(C,R,Z). 
dir[Z], connect[D] => occupied(C+D,R+Z*(q-1)+((-1)**Z)*D,d), ~winD(C,R,Z). 
