
%% Facts:
%% edge[S,E,V]. % player S has a edge E containing vertex V.

#const t_max=10. %% number of moves
#const n_vertices=#count(:vertex[_]).

t[0..t_max].
player[0..1].
~edge[_,_,V], vertex[V].
~edge[S,E,_], winningEdge[S,E].
~t[T], plays[T#mod2,T].  % player black(0) plays at even time rounds, player white at odd.
~vertex[V], ~vertex[I], 2**I < n_vertices, bit[V,I,(V/(2**I))#mod2]. %% if Is bit of V is B=0..1


#exist[T], ~t[T],  time[T].
#exist[T], ~t[T], ~player[S], ~vertex[V], move[S,V,T].
#exist[T], ~t[T], ~player[S], ~vertex[V], board[S,V,T].
#exist[T], ~t[T], ~player[S], ~vertex[V], count[S,V,0..1,T]. % 1 could as be p,q depending on GTTT
#exist[T], ~t[T], ~player[S], occupied[S,T].
#forall[T], ~bit[_,I,_], choose[I,T].
#exist, ~winningEdge[S,E], winEdge[S,E]. %% innermost

~time[T], time[T-1].
~board[S,V,T], board[S,V,T+1].

~board[S,V,T], ~board[1-S,V,T].
~occupied[V,T], board[S,V,T] : player[S].
occupied[V,T], ~board[S,V,T].

%% Frame axioms
time[T], board[S,V,T-1], ~board[S,V,T].
move[S,V,T+1], board[S,V,T], ~board[S,V,T+1].
plays[S,T], board[1-S,V,T] , ~board[1-S,V,T+1].

~win[0].
win[1].

~win[S], winEdge[S,E] : winningEdge[S,E].
win[S], ~winEdge[S,E].

winEdge(S,E), ~board[S,E] : edge[S,E,V].
~winEdge(S,E), winEdge[P,E], : edge[S,E,V].

% counter encoding
~count[S,V-1,I,T], count[S,V,I,T].
~count[S,V-1,I+1,T], count[S,V,I,T].
~move[S,V,T], ~count[S,V-1,I,T], count[S,V,I+1,T].
move[S,V,T], ~count[S,V,I,T], count[S,V-1,I,T].
count[S,0,0,T].
~count[S,0,1,T].
~count[S,n_vertices, 2,T]. %% needs to be adapted
time[T], count[S,n_vertices, 1,T]. %% depends on q and p

%% ACTIONS.
~move[S,V,T], board[S,V,T].
~move[S,V,T], ~occupied[V,T-1].
~move[S,V,T], time[T].
~time[T], occupied[V,T-1], ~choose[I,T]:bit[V,I,0], choose[I,T]:bit[V,I,1], move[white,V,T].

%% Initialisation
~occupied[V,0]. %%
move[0,V,1] : firstmoves[V]. %% break symmetries
