\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%%\NeedsTeXFormat{LaTeX2e}
%%\documentclass{new_tlp}
\input{header.tex}

\title{ SAT Programming}
\author{\IEEEauthorblockN{1\textsuperscript{st} Valentin Mayer-Eichberger}
\IEEEauthorblockA{\textit{Technische Universit\"at} \\
Berlin, Germany\\
valentin@mayer-eichberger.de}
}

\begin{document}

\maketitle

\newcommand{\bcore}{\ensuremath{\text{Bule}_\text{core}}\xspace}

\begin{abstract}
    SAT Programming extends SAT Solving by a declarative modelling language. 
    We propose Bule, a Logic Programming language, based on classical logic that introduces SAT Programming. 
    A ground program in Bule consist of a set of propositional clauses with meaningful literals. 
    The process of translating a non-ground program to propositional clauses is called grounding and is done by iterating over the domain of their variables. 
    The semantics of Bule is simpler than Answer Set Programming or First Order Logic with bounds.  
    Bule also offers techniques based on SAT Solving such as Approximate Model Counting and Quantified Boolean Formulae 
    and enriches such SAT related technologies by a uniform modelling language. 

    %This paper formally defines the language Bule, presents the implementation
    %through key examples and compares to alternative approaches. 


    % With rising usage of SAT solvers the challenge to translate problems to CNF is everywhere. 
    % Such  CNF formulas are usually generated by a problem specific algorithm, encodings of a digital Boolean circuit, translated from a more expressive language such as constraint programming or specified as a fragment of first order logic. 
    % When encodings are  presented in the literature the inner workings are often hidden in subscripts of variables and hard to decipher.

    % In this paper we propose the grounding language \emph{Bule} that is easy to
    % write and read, and helps to generate, reason and compare CNF encodings. 
    % We aim to simplify the approaches above and remove just enough layers between creating and implementing an encodings to facilitate prototyping and debugging. 
    % In this paper we formally define the language \emph{Bule}, compare it to alternative approaches Datalog, FO(ID) and ASP. 
    % Furthermore, we have implemented the grounder and show its usage through a case study.

\end{abstract}


\section{Related Works and Citations and Ideas}


Comparing Answer set programming and satisfiability solving. Key difference
according to \cite{Lierler17} is that ASP has a modelling language and a
grounder attached to it, whereas SAT is focused on problems stemming from
already ground problems. We will try to change that !


\begin{itemize}
    \item Disjunctive Datalog, DLV \cite{Eiter97} or even just Datalog \cite{Gottlob89}
    \item Assat, translating ASP programs to SAT \cite{Lin04}
    \item \cite{Janhunen11}. Compact Translations of Non-disjunctive Answer Set
        Programs to Propositional Clauses
    \item FO(ID). First order logic with bounds (guards) \cite{Wittocx10}
    \item Predicate Logic as a modeling language. IDP System. \cite{Cat18}
    \item Answer Set Programming Lparse/Gringo \cite{Gebser15}, \cite{Ferraris05}
%    \item QBF Solvers \cite{Lonsing17,Tentrup15}
    \item Lazy Clause Generation Interleaving Grounding and Search \cite{Cat15}
\end{itemize}

How do we avoid the challenges in stable models, minimal models, well-founded
semantics etc. ?  Isn't this just Tight, stratified, normal logic program?


A ground Bule program is a set of clauses with literals. 

\section{\bcore}

\section{Bule Syntax and Semantics}

Let $\Sigma,\Omega$ be disjoint countably infinite sets of relation names. 
Each relation name $R\in \Sigma\cup\Omega$ has an associated arity $\mn{ar}(R)$. 
Let us further fix a countably infinite supply of constant symbols \mn{Con} and variable symbols $\mn{Var}$. 
An
\emph{atom} is of the form $R(t_1,\ldots,t_n)$ for some $R\in
\Sigma\cup\Omega$ and $t_1,\ldots,t_n\in\mn{Con}\cup\mn{Var}$ and
$n=\mn{ar}(R)$. An atom $R(t_1,\ldots,t_n)$ is \emph{ground} if
$t_1,\ldots,t_n\in\mn{Con}$; ground atoms are also called
\emph{facts}. An atom $R(t_1,\ldots,t_n)$ is a \emph{$\Sigma$-atom} or
an \emph{$\Omega$-atom} if $R\in \Sigma$ or $R\in \Omega$,
respectively. A \emph{literal} is an atom $R(t_1,\ldots,t_n)$ or a negated atom
$\neg R(t_1,\ldots,t_n)$. 

A \emph{\bcore knowledge base} is a pair $\Kmc=(\Dmc,\Pmc)$ where $\Dmc$ is a
finite set of facts and \Pmc is a set of rules of the form 
%
\[\alpha \Rightarrow _1,\ldots,L_m\]
%
where $\alpha$ is a conjunction of $\Sigma$-literals
and $L_1,\ldots,L_m$ are $\Omega$-literals such that every variable
that occurs in one of the $L_i$ does occur in
a positive literal in $\alpha$.

The semantics of \bcore knowledge bases $\Kmc=(\Dmc,\Pmc)$ is defined via
groundings. A \emph{substitution} is a map
$v:\mn{Var}\cup\mn{Con}\to\mn{Con}$ which is the identity on
$\mn{Con}$, that is, $v(a)=a$, for all $a\in\mn{Con}$. For a Boolean combination of $\Sigma$-atoms $\alpha$ and a
substitution $v$, we define $\Dmc,v\models \alpha$ inductively as
follows: 
%
\begin{align*}
  %
%   \Dmc,v & \models \mn{true} \\
  %
  \Dmc,v & \models R(t_1,\ldots,t_n) && \text{if
  $R(v(t_1),\ldots,v(t_n))\in \Dmc$} \\
  %
  \Dmc, v& \models \neg \alpha && \text{if $\Dmc,v\not\models \alpha$}
  \\
  %
  \Dmc, v& \models \alpha \wedge \alpha' && \text{if $\Dmc,v\models
  \alpha$ and $\Dmc,v\models\alpha'$}
  %
\end{align*}
%
If $\Dmc,v\models\alpha$, we call $v$ a \emph{model} of $\alpha$.


Now, we assign a set of clauses $\mn{cl}(\Kmc)$ to the \bcore knowledge
base $\Kmc=(\Dmc,\Pmc)$ as follows:
%
\[v(L_1)\vee\ldots\vee v(L_n)\in \mn{cl}(\Kmc)\]
%
whenever there is a rule $\alpha \Rightarrow L_1,\ldots,L_n\in\Pmc$ and $v$ is a model of $\alpha$. 
Note that $\mn{cl}(\Kmc)$ is a set of clauses over facts which we treat as propositional variables here.  
We say that $\Kmc$ is \emph{satisfiable} if the set of clauses $\mn{cl}(\Kmc)$ is satisfiable. 

\section{Bule}

\vale{To distinguish $\Sigma$- and $\Omega$-atoms we
write them with parenthesis $p[]$ or brackets $q[]$, respectively. }


{\color{red}For simplicity, I don't use any syntactic sugar, that is,
%
\begin{itemize}

  \item no empty $\alpha$ as in the generating clauses
    $c(I,J),b(I,J)$,

  \item no integers as in $c(I,J),c(I+1,J)$ or $dom[1..k]$,

  \item no $[]$-atoms on the right-hand side, as in $edge[X,\_ ]
    \Rightarrow node[X]$

\end{itemize}
Moreover, there are no rules of the form $[c(I)]:dom[I]$ yet. 
}

\section{Examples}

\subsection{The Counter Encoding for Cardinality Constraints}


Given the search atoms $element(1\ldots n)$, the counter encodings encodes the
number of true elements (CNF encoding of Cardinality as defined in \cite{Sinz05})
under the current assignment:

\begin{lstlisting}
~count(I,J),  count(I+1,J).
 count(I-1,J-1), ~count(I,J).
~element(I), ~count(I-1,J-1), count(I,J).
 element(I), ~count(I,J),     count(I-1,J).

 count(0,0).
~count(0,1).
 count(n,k).
~count(n,k+1).
\end{lstlisting}

\section{Relationship to other KR languages}

Datalog, FO(id)?, ASP

\section{Complexity}

\bibliographystyle{plain}
\bibliography{main}

\end{document}
