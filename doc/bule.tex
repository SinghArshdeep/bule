\NeedsTeXFormat{LaTeX2e}

\documentclass{new_tlp}

%\documentclass{article}
\usepackage{misc}
\usepackage{xspace}
\usepackage{color}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\lstset{
basicstyle=\ttfamily,
literate={~}{{$\neg$}}1
%literate={~}{{\fontfamily{ptm}\selectfont \textasciitilde}}1
}

\newcommand{\TODO}[1]{\textcolor[rgb]{1.00,0.00,0.00}{todo: #1} }
\newcommand{\vale}[1]{\textcolor[rgb]{0.00,0.00,0.54296875}{vale: #1} }

\newcommand\bigforall{\mbox{\Large $\mathsurround0pt\forall$}}
\newcommand\bigexists{\mbox{\Large $\mathsurround0pt\exists$}}


\title{ SAT Programming With \emph{BULE}}
\author{
%    Jean Christoph Jung\footnote{Universit√§t Bremen, Germany} \and 
    Valentin Mayer-Eichberger\footnote{Technische Universit\"at Berlin, Germany} 
}

\jdate{May 2020}
%\pubyear{2003}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}

\begin{document}

\maketitle


\begin{abstract}
    In this paper we introduce Bule, a Logic Programming paradigm based on clauses in its purest form. 
    A ground program in Bule consist simply of set propositional of propositional clauses. 
    None-ground clauses ground to clauses in conjunctive normal form by iterating over the domain of their term variables and leading. 
    The semantics of Bule corresponds to Boolean satisfiability and is simpler than that of other related paradigm such as Answer Set Programming and First Order Logic with bounds.  
    The goal of the language is a declarative and concise definition language of CNF encodings. 
    Bule offers techniques related to SAT Solving such as Approximate Model Counting and Quantified Boolean Formulae. 
    This paper formally defines the language Bule, presents the implementation through key examples and compares to alternative approaches. 


    % With rising usage of SAT solvers the challenge to translate problems to CNF is everywhere. 
    % Such  CNF formulas are usually generated by a problem specific algorithm, encodings of a digital Boolean circuit, translated from a more expressive language such as constraint programming or specified as a fragment of first order logic. 
    % When encodings are  presented in the literature the inner workings are often hidden in subscripts of variables and hard to decipher.

    % In this paper we propose the grounding language \emph{Bule} that is easy to
    % write and read, and helps to generate, reason and compare CNF encodings. 
    % We aim to simplify the approaches above and remove just enough layers between creating and implementing an encodings to facilitate prototyping and debugging. 
    % In this paper we formally define the language \emph{Bule}, compare it to alternative approaches Datalog, FO(ID) and ASP. 
    % Furthermore, we have implemented the grounder and show its usage through a case study.

\end{abstract}

\begin{itemize}
    \item Datalog Disjunctive, DLV 
    \item Answer Set Programming Lparse/Gringo
    \item FO(ID), Lazy Clause Generation
\end{itemize}

\begin{itemize}
    \item Datalog Disjunctive, DLV 
    \item Answer Set Programming Lparse/Gringo
    \item FO(ID), Lazy Clause Generation
\end{itemize}



\section{Bule Syntax and Semantics}

Let $\Sigma,\Omega$ be disjoint countably infinite sets of relation names. 
Each relation name $R\in \Sigma\cup\Omega$ has an associated arity $\mn{ar}(R)$. 
Let us further fix a countably infinite supply of constant symbols \mn{Con} and variable symbols $\mn{Var}$. 
An
\emph{atom} is of the form $R(t_1,\ldots,t_n)$ for some $R\in
\Sigma\cup\Omega$ and $t_1,\ldots,t_n\in\mn{Con}\cup\mn{Var}$ and
$n=\mn{ar}(R)$. 
An atom $R(t_1,\ldots,t_n)$ is \emph{ground} if $t_1,\ldots,t_n\in\mn{Con}$; ground atoms are also called \emph{facts}. An atom $R(t_1,\ldots,t_n)$ is a \emph{$\Sigma$-atom} or an \emph{$\Omega$-atom} if $R\in \Sigma$ or $R\in \Omega$, respectively. 
A \emph{literal} is an atom $R(t_1,\ldots,t_n)$ or a negated atom $\neg R(t_1,\ldots,t_n)$. 
\vale{To distinguish $\Sigma$- and $\Omega$-atoms we write them with parenthesis $p[]$ or brackets $q[]$, respectively. }

A \emph{Bule knowledge base} is a pair $\Kmc=(\Dmc,\Pmc)$ where $\Dmc$ is a finite set of facts and \Pmc is a set of rules of the form 
%
\[\alpha \Rightarrow L_1,\ldots,L_m\]
%
where $\alpha$ is a Boolean formula over $\Sigma$-atoms and $L_1,\ldots,L_m$ are $\Omega$-literals such that every variable that occurs in one of the $L_i$ does occur positively in $\alpha$.
\footnote{Here we would need the definition of the
  \emph{polarity} of a variable in a Boolean combination of
atoms.}\footnote{Why only clauses on the right-hand side?}
{\color{red}For simplicity, I don't use any syntactic sugar, that is,
%
\begin{itemize}

  \item no empty $\alpha$ as in the generating clauses $c(I,J),b(I,J)$,

  \item no integers as in $c(I,J),c(I+1,J)$ or $dom[1..k]$,

  \item no $[]$-atoms on the right-hand side, as in $edge[X,\_ ] \Rightarrow node[X]$

\end{itemize}
Moreover, there are no rules of the form $[c(I)]:dom[I]$ yet. 
}

The semantics of Bule knowledge base $\Kmc=(\Dmc,\Pmc)$ is defined via groundings. 
A \emph{substitution} is a map $v:\mn{Var}\cup\mn{Con}\to\mn{Con}$ which is the identity on $\mn{Con}$. 
For a Boolean combination of $\Sigma$-atoms $\alpha$ and a substitution $v$, we define $\Dmc,v\models \alpha$ inductively as follows follows: 
%
\begin{align*}
  %
%   \Dmc,v & \models \mn{true} \\
  %
  \Dmc,v & \models R(t_1,\ldots,t_n) && \text{if
  $R(v(t_1),\ldots,v(t_n))\in \Dmc$} \\
  %
  \Dmc, v& \models \neg \alpha && \text{if $\Dmc,v\not\models \alpha$}
  \\
  %
  \Dmc, v& \models \alpha \wedge \alpha' && \text{if $\Dmc,v\models
  \alpha$ and $\Dmc,v\models\alpha'$}
  %
\end{align*}
%
If $\Dmc,v\models\alpha$, we call $v$ a \emph{model} of $\alpha$.

Now, we assign a set of clauses $\mn{cl}(\Kmc)$ to the Bule knowledge
base $\Kmc=(\Dmc,\Pmc)$ as follows:
%
\[v(L_1)\vee\ldots\vee v(L_n)\in \mn{cl}(\Kmc)\]
%
whenever there is a rule $\alpha \Rightarrow L_1,\ldots,L_n\in\Pmc$ and $v$ is a model of $\alpha$. 
Note that $\mn{cl}(\Kmc)$ is a set of clauses over facts which we treat as propositional variables here.  
We say that $\Kmc$ is \emph{satisfiable} if the set of clauses $\mn{cl}(\Kmc)$ is satisfiable. 

\section{Syntactic Sugar}

\section{Examples}

\subsection{Counter Encoding}

The counter encoding introduced in \cite{sinz2005} written in Bule. 

Given the predicate $element(1\ldots n)$, 
the counter encodings counts the number of true elements.

\begin{lstlisting}
~count(I,J),  count(I+1,J).
~count(I,J),  count(I-1,J-1).
~element(I), ~count(I-1,J-1), count(I,J).
 element(I), ~count(I,J),     count(I-1,J).

 count(0,0).
~count(0,1).
 count(n,k).
~count(n,k+1).
\end{lstlisting}

\section{Relationship to other KR languages}

Datalog, FO(id)?, ASP

\section{Complexity}

\bibliographystyle{acmtrans}
\bibliography{main}

\end{document}
