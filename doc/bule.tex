\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%%\NeedsTeXFormat{LaTeX2e}
%%\documentclass{new_tlp}
\input{header.tex}

\title{ SAT Programming}
\author{\IEEEauthorblockN{1\textsuperscript{st} Valentin Mayer-Eichberger}
\IEEEauthorblockA{\textit{Technische Universit\"at} \\
Berlin, Germany\\
valentin@mayer-eichberger.de}
}

\begin{document}

\maketitle

\newcommand{\bcore}{\ensuremath{\text{Bule}_\text{core}}\xspace}
\newcommand{\bule}{\ensuremath{\text{Bule}}\xspace}


\begin{abstract}
    SAT Programming extends SAT Solving by a declarative modelling language. 
    We propose Bule, a Logic Programming language, based on classical logic that introduces SAT Programming. 
    A ground program in Bule consist of a set of propositional clauses with meaningful literals. 
    The process of translating a non-ground program to propositional clauses is called grounding and is done by iterating over the domain of their variables. 
    The semantics of Bule is simpler than Answer Set Programming or First Order Logic with bounds.  
    Bule also offers techniques based on SAT Solving such as Approximate Model Counting and Quantified Boolean Formulae 
    and enriches such SAT related technologies by a uniform modelling language. 

    %This paper formally defines the language Bule, presents the implementation
    %through key examples and compares to alternative approaches. 


    % With rising usage of SAT solvers the challenge to translate problems to CNF is everywhere. 
    % Such  CNF formulas are usually generated by a problem specific algorithm, encodings of a digital Boolean circuit, translated from a more expressive language such as constraint programming or specified as a fragment of first order logic. 
    % When encodings are  presented in the literature the inner workings are often hidden in subscripts of variables and hard to decipher.

    % In this paper we propose the grounding language \emph{Bule} that is easy to
    % write and read, and helps to generate, reason and compare CNF encodings. 
    % We aim to simplify the approaches above and remove just enough layers between creating and implementing an encodings to facilitate prototyping and debugging. 
    % In this paper we formally define the language \emph{Bule}, compare it to alternative approaches Datalog, FO(ID) and ASP. 
    % Furthermore, we have implemented the grounder and show its usage through a case study.

\end{abstract}


\section{Related Works and Citations and Ideas}


Comparing Answer set programming and satisfiability solving. Key difference
according to \cite{Lierler17} is that ASP has a modelling language and a
grounder attached to it, whereas SAT is focused on problems stemming from
already ground problems. We will try to change that !


\begin{itemize}
    \item Disjunctive Datalog, DLV \cite{Eiter97} or even just Datalog \cite{Gottlob89}
    \item Assat, translating ASP programs to SAT \cite{Lin04}
    \item \cite{Janhunen11}. Compact Translations of Non-disjunctive Answer Set
        Programs to Propositional Clauses
    \item FO(ID). First order logic with bounds (guards) \cite{Wittocx10}
    \item Predicate Logic as a modeling language. IDP System. \cite{Cat18}
    \item Answer Set Programming Lparse/Gringo \cite{Gebser15}, \cite{Ferraris05}
%    \item QBF Solvers \cite{Lonsing17,Tentrup15}
    \item Lazy Clause Generation Interleaving Grounding and Search \cite{Cat15}
\end{itemize}

How do we avoid the challenges in stable models, minimal models, well-founded
semantics etc. ?  Isn't this just Tight, stratified, normal logic program?


A ground Bule program is a set of clauses with literals. 


\section{Bule Syntax and Semantics}

For didactic reasons, we define syntax and semantics of \bule in two
stages. We start with \bcore which contains the main functionality and
then present several extensions which ease modeling. 

\subsection{\bcore}

Let $\Sigma,\Omega$ be disjoint countably infinite sets of relation
symbols.  Each relation symbol $R\in \Sigma\cup\Omega$ has an
associated arity $\mn{ar}(R)$.  Let us further fix a countably
infinite supply of constant symbols \mn{Con} and variable symbols
$\mn{Var}$.  An \emph{atom} is of the form $R(t_1,\ldots,t_n)$ for
some $R\in \Sigma\cup\Omega$ and
$t_1,\ldots,t_n\in\mn{Con}\cup\mn{Var}$ and $n=\mn{ar}(R)$. An atom
$R(t_1,\ldots,t_n)$ is \emph{ground} if $t_1,\ldots,t_n\in\mn{Con}$;
ground atoms are also called \emph{facts}. An atom $R(t_1,\ldots,t_n)$
is a \emph{$\Sigma$-atom} or an \emph{$\Omega$-atom} if $R\in \Sigma$
or $R\in \Omega$, respectively. A \emph{literal} is an atom
$R(t_1,\ldots,t_n)$ or a negated atom $\neg R(t_1,\ldots,t_n)$. An
\emph{instance} is a finite set of facts. 
A \emph{substitution} is a map
$v:\mn{Var}\cup\mn{Con}\to\mn{Con}$ which is the identity on
$\mn{Con}$, that is, $v(a)=a$, for all $a\in\mn{Con}$. Let $\Imc$ be
an instance, $\alpha$ a Boolean formula over atoms, and
$v$ a substitution. We define $\Dmc,v\models \alpha$ inductively as
follows: 
%
\begin{align*}
  %
  %
  \Imc,v & \models R(t_1,\ldots,t_n) && \text{if
  $R(v(t_1),\ldots,v(t_n))\in \Imc$} \\
  %
  \Imc, v& \models \neg \alpha && \text{if $\Imc,v\not\models \alpha$}
  \\
  %
  \Imc, v& \models \alpha \wedge \alpha' && \text{if $\Imc,v\models
  \alpha$ and $\Imc,v\models\alpha'$}
  %
\end{align*}
%
If $\Imc,v\models\alpha$, we call $v$ a \emph{model} of $\alpha$ over
the instance \Imc. A \emph{clause} is a disjunction of literals.


A \emph{\bcore-program} is a pair $\Pi=(\Imc,\Pmc)$ where $\Imc$ is a
finite set of facts and \Pmc is a set of rules of the form 
%
\[B_1, \ldots, B_k \Rightarrow L_1, \ldots, L_m\]
%
where $B_1,\ldots,B_k$ are $\Sigma$-atoms
and $L_1,\ldots,L_m$ are $\Omega$-literals such that every variable
that occurs in one of the $L_i$ does occur in one of the 
$B_i$.

The semantics of \bcore-programs $\Pi=(\Imc,\Pmc)$ is defined via
groundings. More precisely, with every \bcore-program
$\Pi=(\Imc,\Pmc)$, we associate a set $\mn{cl}(\Pi)$ of ground clauses
as follows.  For every rule $B_1,\ldots,B_k \Rightarrow L_1,\ldots,
L_n\in\Pmc$ and every model $v$ of $B_1\wedge\ldots\wedge B_k$ in
\Imc, $\mn{cl}(\Pi)$ contains the clause
%
\[v(L_1)\vee\ldots\vee v(L_n).\]
%
We say that $\Pi$ is \emph{satisfiable} if the set of clauses
$\mn{cl}(\Pi)$ is satisfiable, that is, there is an instance $\Mmc$
such that $\Mmc,\emptyset \models\mn{cl}(\Pi)$ (note that
$\mn{cl}(\Pi)$ is ground, so the empty substitution $\emptyset$
suffices).

{\color{red} Although \bcore is a relatively simple language, we can
already model natural problems with it. To distinguish $\Sigma$- and
$\Omega$-atoms we write them with parenthesis $p[\cdot]$ or brackets
$q(\cdot)$,
respectively.



\begin{example}
  
\end{example}

}


\subsection{Full \bule}

We extend \bcore with \emph{extended instances}, \emph{iterators},
\emph{integers}, and \emph{implicit declarations} and define the
semantics by mapping to \bcore. We start with definitions. 

An \emph{extended instance \Jmc} is a union of an instance \Imc with a
a set of rules of the form
%
\[B_1,\ldots,B_k\Rightarrow B\]
%
where $B,B_1,\ldots,B_k$ are $\Sigma$-atoms and every variable that
occurs in $B$ occurs in one of the $B_i$. We further require that the
rules in \Jmc are acyclic in the sense that the graph $G_\Jmc = (V_\Jmc,E_\Jmc)$ is
acyclic, where $V_\Jmc$ is the set of all relation names that occur in
\Jmc and $(P,R)\in E_\Jmc$ if there is a rule
$B_1,\ldots,B_k\Rightarrow B$ where $B$ is an $R$-atom and some $B_i$
is an $P$-atom.  

An extended \bcore-program is now a pair $\Pi=(\Jmc,\Pmc)$ where
$\Jmc$ is an extended instance and \Pmc a set of rules as above. Every
extended \bcore-program \emph{induces} a \bcore-program $(\Imc,\Pmc)$
via an inductive process as follows. Let $\Imc_0$ be the set of facts
in \Jmc, and define $\Imc_{i+1}$ from $\Imc_i$ by adding, for every
rule $B_1,\ldots,B_k\Rightarrow B\in \Jmc$ and every model $v$ of
$B_1\wedge \ldots \wedge B_k$ over $\Imc_i$, the fact $v(B)$ to
$\Imc_{i+1}$. Note that this process terminates due to acyclicity of
\Jmc. An extended \bcore-program is satisfiable if the induced
\bcore-program is satisfiable. 

Extended \bcore-programs can be used to define auxiliary facts which
are often useful for modeling, e.g.~see the following example. 
%
\begin{example}
  %
  \textcolor{red}{TODO.}
  %
\end{example}


{\color{red}For simplicity, I don't use any syntactic sugar, that is,
%
\begin{itemize}

  \item no empty $\alpha$ as in the generating clauses
    $c(I,J),b(I,J)$,

  \item no integers as in $c(I,J),c(I+1,J)$ or $dom[1..k]$,


\end{itemize}
Moreover, there are no rules of the form $[c(I)]:dom[I]$ yet. 
}

\section{Examples}

\subsection{The Counter Encoding for Cardinality Constraints}


Given the search atoms $element(1\ldots n)$, the counter encodings encodes the
number of true elements (CNF encoding of Cardinality as defined in \cite{Sinz05})
under the current assignment:

\begin{lstlisting}
~count(I,J),  count(I+1,J).
 count(I-1,J-1), ~count(I,J).
~element(I), ~count(I-1,J-1), count(I,J).
 element(I), ~count(I,J),     count(I-1,J).

 count(0,0).
~count(0,1).
 count(n,k).
~count(n,k+1).
\end{lstlisting}

\section{Relationship to other KR languages}

Datalog, FO(id)?, ASP

\section{Complexity}

\bibliographystyle{plain}
\bibliography{main}

\end{document}
