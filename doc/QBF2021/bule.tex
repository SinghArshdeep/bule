\documentclass[runningheads]{llncs}

\input{header.tex}

\title{ QBF Programming with \emph{Bule}}

\author{Jean Christoph Jung\inst{1} \and Valentin Mayer-Eichberger\inst{2} \and
Abdallah Saffidine\inst{3}}
\authorrunning{Jung et.al.}

\institute{Universit\"at Bremen, Germany \and Technische Universit\"at Berlin, Germany \and University of New South Wales, Sydney, Australia }

\begin{document}

\maketitle

\begin{abstract}
    Bule introduces the concept of QBF Programming - a paradigm that complements QBF solving with an intuitive modelling language. 
    The language is easy to learn and has a transparent grounding process that unrolls firt order term variables to a ground CNF formula with a quantifier prefix. 
%    Bule separates domain predicates for the grounding process and search variables syntactically. 
    The semantics of the language is strict and well-behaved and we complexity classes for both ground and non-ground programs. 
%    Our implementation can connect to any QBF solver and in case of only existential variables SAT solver. 
    Finally, Bule is a tool to learn QBF and SAT Programming due to its easy format and flexible integration with any QBF and SAT solvers. 
\end{abstract}

%% Motivation: 
%% 
%% simpler and more strict, yet expressive enough. So it's more well-behaved and defined. 
%% This could lead solver developers to go for the actual non-ground specification of the problem. 
%% Orthogonal to this hierarchy is the hierarchy of quantifier levels. 
%% And a problem can be horn (max 1 positive literal per clause) or not. 
%% 
%% focus on grounding language (not fast grounder yet)
%% 
%% simpler and more strict: 
%% * non-recursive 
%% * separation of grounding and search variables
%%     * Because we make this distinction, we can rule out recursion. 
%% * no functional terms
%%  
%% 
%% Contributions
%% - SAT Programming
%% actually, a QSAT Programming Language: PSpace 
%% We fix the hebrand terms via (LOOK AT THIS: some problems cant be expressed nicely in BULE?)
%% There is a working implementation, used in practice. 
%% Formal analysis of non-ground modelling language 
%% Much cleaner than ASP for NON-Ground modelling lanugage 
%% ASP(ground) is sigma2P, 
%% ASP is not intended for modelling PSPACE languages
%% Loop formulas> https://dl.acm.org/doi/abs/10.1145/1131313.1131316 SAT vs ASP
%% 1. Fix Format 
%% 2. fix the Examples for a MVP(minimal viable paper).
%% Why iterators in nice and not core? (can be expressed with extra variables)
%% Debate: Should we allow the following: 
%% Exponents? facts[2..2^K].
%% Free variables?
%% Syntax 

\section{Introduction and Motivation}

\paragraph{Introduction}

Creating CNF formulas is a difficult and errorprone process. 
The DIMACS format used by SAT solvers is difficult to read and debugg.  
To the best of our knowlede, formal non-ground model languages are rare for SAT solving and not existing in QBF. 
For SAT there are modelling frameworks like PySAT \cite{PySAT2018}.
The modelling and solving framework \emph{Answer Set Programming} ASP (\vale{CITE}) ASP provides a non-ground modelling language GRINGO (cite), but the semantical issues of non-monotonic logics is difficult and for many NP-Complete problems not needed - and for QBF not established (CITE QASP). 

We propose a modelling language for SAT and QBF community with simpler syntax and semnatics than ASP. In this abstract we introduce the syntax, give examples and discuss the complexity classes of variants of syntactical elements. 

\paragraph{Running Example}

Reachability Code Cybic. 

\section{The Bule Language}

\begin{align*}
    & \bigwedge_{\text{Generator}} \bigvee_{\text{Iterator}} \text{Literal} \\ 
\end{align*}

Brief Syntax and Semantics
EBNF ? 

\subsection{Complexity}

\paragraph{Table}

\abd{Analyse} and \jean{check}. 

In Table \ref{tab:complexity} we give an overview of the complexity classes
that each fragment of is complete for. The proof follows from the reduction of
Turing machines into an expression in Bule using subset of constructs.

\begin{table}
  \caption{Complexity Results}
  \centering
  \label{tab:complexity}
  \begin{tabular}{lccc}
    \toprule
    Clauses  & \multicolumn{1}{c}{Horn}  & \multicolumn{2}{c}{Any} \\
    \cmidrule{3-4}
    $\forall$ Quantifiers   & $\cmark$ & $\xmark$ & $\cmark$ \\
    \midrule
    \bflat   & \ptime    & \np       & \pspace  \\
    \bcore   & \exptime & \nexptime  & \expspace  \\
    \bfull   & &     &   \\
    \bottomrule
  \end{tabular}
\end{table}


\section{Examples}

\paragraph{Counter}
\paragraph{SAT Reachability}
\paragraph{QBF Reachability}
\paragraph{Turing Machine}

\section{Related Work}
 \begin{itemize}
     \item Writing Declarative Specification for Clauses: \cite{Gebser16} 
         \begin{itemize}
             \item The proposed language is a syntactic alternative to \bcore
             \item It uses translation forth and back between ASP
             \item no complexity for non-ground language analysed. 
             \item Does not distinguish syntactically between grounding facts and search variables as we do. 
             \item \bnice provides convenient modelling support that their language does not have. Implicit variables for instances. 
         \end{itemize}
     \item ASP vs SAT: Why are there so many Loop Formulas. (reachability to SAT without additional variables is large): \cite{Lifschitz04} .
     \item Programming a SAT formula via frameworks (e.g. \cite{PySAT18},
         more?), then this is a imperative description, but NOT a declarative
         one! Complexity results on Python are undecided of course. 
     \item Disjunctive Datalog, DLV \cite{Eiter97} or even just Datalog \cite{Gottlob89}
     \item Relate it to Complexity of different flavors of logic programming \cite{Gottlob01}
     \item Assat, translating ASP programs to SAT \cite{Lin04}
     \item \cite{Janhunen11}. Compact Translations of Non-disjunctive Answer Set
         Programs to Propositional Clauses
     \item FO(ID). First order logic with bounds (guards) \cite{Wittocx10}
     \item Predicate Logic as a modeling language. IDP System. \cite{Cat18}
     \item Answer Set Programming Lparse/Gringo \cite{Gebser15}, \cite{Ferraris05}
 %    \item QBF Solvers \cite{Lonsing17,Tentrup15}
     \item Lazy Clause Generation Interleaving Grounding and Search \cite{Cat15}
     \item Relationship with Effectively Propositional Logic (EPL) \cite{Moura08}? 
     \item http://picat-lang.org/
 \end{itemize}

\section{Conclusion and Further Work}

\bibliographystyle{plain}
\bibliography{main}

\end{document}

